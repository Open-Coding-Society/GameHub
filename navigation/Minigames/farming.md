---
layout: base
title: Farming
description: Farming Game
permalink: /farming
Author: Ian
---

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Harvest Haven</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<style>
  body {
    background-color: #f8f9fa;
    font-family: 'Arial', sans-serif;
  }
  #gameCanvas {
    border: 3px solid #495057;
    border-radius: 5px;
    background-color: #8b9d83;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    cursor: pointer;
    image-rendering: pixelated;
  }
  .inventory-slot {
    width: 60px;
    height: 60px;
    border: 2px solid #6c757d;
    border-radius: 5px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin: 3px;
    background-color: #e9ecef;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 2rem;
    position: relative;
    overflow: hidden;
  }
  .inventory-slot.selected-slot {
    border: 3px solid #0d6efd;
    background-color: #cfe2ff;
    animation: slotPulse 0.5s;
  }
  @keyframes slotPulse {
    0% { box-shadow: 0 0 0 0 #0d6efd44; }
    100% { box-shadow: 0 0 10px 5px #0d6efd22; }
  }
  .inventory-slot .slot-label {
    position: absolute;
    bottom: 2px;
    right: 4px;
    font-size: 0.8rem;
    color: #495057;
    background: #fff8;
    border-radius: 3px;
    padding: 0 2px;
  }
  .card {
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  }
  .card-header {
    font-weight: bold;
    background-color: #e9ecef;
  }
  .controls {
    background-color: #e9ecef;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 20px;
  }
  .btn-sm {
    padding: 0.25rem 0.5rem;
    font-size: 0.875rem;
  }
  .modal-content {
    border-radius: 10px;
  }
  .merchant-item {
    transition: all 0.2s;
  }
  .merchant-item:hover {
    transform: translateY(-3px);
  }
</style>

<div class="container py-4">
  <div class="text-center mb-4">
    <h1 class="display-4">Harvest Haven</h1>
    <p class="lead">A Stardew Valley inspired farming adventure</p>
  </div>

  <div class="row">
    <div class="col-lg-8">
      <div class="controls mb-3">
        <h5>Controls</h5>
        <p>
          <strong>WASD</strong> to move |
          <strong>E</strong> or <strong>Click</strong> to interact |
          <strong>Click</strong> inventory items to select
        </p>
        <p>
          Interact with objects and the merchant by facing them and pressing <strong>E</strong> or <strong>clicking</strong> on them in the game area.
        </p>
      </div>
      <canvas id="gameCanvas" width="800" height="600" tabindex="0"></canvas>
    </div>
    <div class="col-lg-4">
      <div class="card mb-3">
        <div class="card-header d-flex justify-content-between align-items-center">
          <span>Player Inventory</span>
          <span class="badge bg-primary">10 slots</span>
        </div>
        <div class="card-body" id="inventory">
          <!-- Inventory slots will be generated by JS -->
        </div>
      </div>
      <div class="card mb-3">
        <div class="card-header">Stats</div>
        <div class="card-body">
          <p><strong>Coins:</strong> <span id="coins" class="badge bg-success">100</span></p>
          <p><strong>Day:</strong> <span id="day" class="badge bg-info">1</span></p>
          <p><strong>Time:</strong> <span id="time" class="badge bg-secondary">08:00</span></p>
        </div>
      </div>
      <div class="card">
        <div class="card-header">Current Tool</div>
        <div class="card-body">
          <p id="currentTool">None selected</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Merchant Modal -->
<div class="modal fade" id="merchantModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Merchant's Shop</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info">
          "Hello farmer! What can I do for you today?"
        </div>
        <h6 class="mt-3 mb-2">Buy Items</h6>
        <div class="row" id="merchantItems">
          <!-- Merchant items will be populated by JS -->
        </div>
        <hr>
        <h6 class="mt-3 mb-2">Sell Items</h6>
        <div class="d-flex justify-content-between align-items-center mb-3">
          <div>
            <button class="btn btn-success sell-btn">Sell All Crops</button>
            <button class="btn btn-success sell-btn ms-2">Sell All Ores</button>
          </div>
          <div>
            <button class="btn btn-danger sell-btn">Sell Everything</button>
          </div>
        </div>
        <div id="sellPreview" class="bg-light p-2 rounded">
          <!-- Items to sell will appear here -->
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
  // --- Emoji assets ---
  const EMOJIS = {
    player: "ðŸ‘¨â€ðŸŒ¾",
    merchant: "ðŸ§‘â€ðŸ¦³",
    wheat: "ðŸŒ¾",
    carrot: "ðŸ¥•",
    pumpkin: "ðŸŽƒ",
    copper: "ðŸŸ¤",
    iron: "âšª",
    gold: "ðŸŸ¡",
    diamond: "ðŸ’Ž",
    tilled: "â¬›",
    grass: "ðŸŸ©",
    water: "ðŸŸ¦",
    dirt: "ðŸŸ«"
  };

  // --- Game State ---
  const TILE_SIZE = 32; // Bigger tiles for readability
  const PLAYER_SIZE = 32;
  const gameState = {
    player: {
      x: 400,
      y: 300,
      speed: 4,
      direction: 'down',
      inventory: [],
      coins: 100,
      selectedSlot: null,
      tools: {
        sickle: { name: 'Sickle', type: 'tool', uses: Infinity, action: 'harvest', emoji: "ðŸ”ª" },
        pickaxe: { name: 'Pickaxe', type: 'tool', uses: Infinity, action: 'mine', emoji: "â›ï¸" }
      }
    },
    map: {
      tiles: [],
      width: 25,
      height: 18,
      tileSize: TILE_SIZE,
      merchantPosition: { x: 3, y: 3 }
    },
    crops: [],
    ores: [],
    merchant: {
      items: [
        { name: 'Wheat Seed', type: 'seed', price: 10, rarity: 'common', growthTime: 3, produces: 'Wheat', emoji: EMOJIS.wheat },
        { name: 'Carrot Seed', type: 'seed', price: 20, rarity: 'uncommon', growthTime: 5, produces: 'Carrot', emoji: EMOJIS.carrot },
        { name: 'Pumpkin Seed', type: 'seed', price: 50, rarity: 'rare', growthTime: 8, produces: 'Pumpkin', emoji: EMOJIS.pumpkin },
        { name: 'Fertilizer', type: 'item', price: 30, effect: 'growthSpeed', value: 0.8, emoji: "ðŸ’©" }
      ]
    },
    time: {
      day: 1,
      hour: 8,
      minute: 0,
      paused: false
    },
    keys: { w: false, a: false, s: false, d: false, e: false }
  };

  // --- DOM Elements ---
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const coinsDisplay = document.getElementById('coins');
  const dayDisplay = document.getElementById('day');
  const timeDisplay = document.getElementById('time');
  const inventoryDiv = document.getElementById('inventory');
  const currentToolDisplay = document.getElementById('currentTool');
  let merchantModal = null;

  // --- Helper: Get tile under pixel coordinates ---
  function getTileAtPixel(x, y) {
    return {
      tileX: Math.floor(x / gameState.map.tileSize),
      tileY: Math.floor(y / gameState.map.tileSize)
    };
  }

  // --- Helper: Get object at tile ---
  function getObjectAtTile(tileX, tileY) {
    if (tileX === gameState.map.merchantPosition.x && tileY === gameState.map.merchantPosition.y) {
      return { type: 'merchant' };
    }
    const cropIndex = gameState.crops.findIndex(c =>
      Math.floor(c.x / gameState.map.tileSize) === tileX &&
      Math.floor(c.y / gameState.map.tileSize) === tileY
    );
    if (cropIndex !== -1) return { type: 'crop', index: cropIndex };
    const oreIndex = gameState.ores.findIndex(o =>
      Math.floor(o.x / gameState.map.tileSize) === tileX &&
      Math.floor(o.y / gameState.map.tileSize) === tileY
    );
    if (oreIndex !== -1) return { type: 'ore', index: oreIndex };
    if (gameState.map.tiles[tileY] && gameState.map.tiles[tileY][tileX] === 'tilled_soil') {
      return { type: 'tilled_soil' };
    }
    return null;
  }

  // --- Map Generation ---
  function generateMap() {
    for (let y = 0; y < gameState.map.height; y++) {
      gameState.map.tiles[y] = [];
      for (let x = 0; x < gameState.map.width; x++) {
        if (Math.random() < 0.08) {
          gameState.map.tiles[y][x] = 'water';
        } else if (Math.random() < 0.18) {
          gameState.map.tiles[y][x] = 'grass';
        } else {
          gameState.map.tiles[y][x] = 'dirt';
        }
      }
    }
    for (let y = 7; y < 12; y++) {
      for (let x = 10; x < 18; x++) {
        gameState.map.tiles[y][x] = 'tilled_soil';
      }
    }
    gameState.map.tiles[gameState.map.merchantPosition.y][gameState.map.merchantPosition.x] = 'dirt';
  }

  // --- Ore Generation ---
  function generateOres() {
    gameState.ores = [];
    const oreTypes = [
      { name: 'Copper Ore', rarity: 'common', value: 20, spawnChance: 0.08, emoji: EMOJIS.copper },
      { name: 'Iron Ore', rarity: 'uncommon', value: 50, spawnChance: 0.04, emoji: EMOJIS.iron },
      { name: 'Gold Ore', rarity: 'rare', value: 100, spawnChance: 0.015, emoji: EMOJIS.gold },
      { name: 'Diamond', rarity: 'legendary', value: 500, spawnChance: 0.005, emoji: EMOJIS.diamond }
    ];
    for (let y = 0; y < gameState.map.height; y++) {
      for (let x = 0; x < gameState.map.width; x++) {
        if (gameState.map.tiles[y][x] === 'dirt' || gameState.map.tiles[y][x] === 'grass') {
          for (const ore of oreTypes) {
            if (Math.random() < ore.spawnChance) {
              gameState.ores.push({
                x: x * gameState.map.tileSize,
                y: y * gameState.map.tileSize,
                type: ore.name,
                rarity: ore.rarity,
                value: ore.value,
                emoji: ore.emoji
              });
              break;
            }
          }
        }
      }
    }
  }

  // --- Inventory Management ---
  function setupInventory() {
    inventoryDiv.innerHTML = '';
    for (let i = 0; i < 10; i++) {
      const slot = document.createElement('div');
      slot.className = 'inventory-slot';
      if (i === gameState.player.selectedSlot) slot.classList.add('selected-slot');
      slot.id = `slot-${i}`;
      slot.addEventListener('click', () => selectItem(i));
      const item = gameState.player.inventory[i];
      if (item) {
        slot.innerHTML = (item.emoji || getItemEmoji(item)) +
          `<span class="slot-label">${item.name.split(" ")[0]}</span>`;
        slot.title = item.name;
      }
      inventoryDiv.appendChild(slot);
    }
    coinsDisplay.textContent = gameState.player.coins;
    // Animate selected tool
    const selected = document.querySelector('.inventory-slot.selected-slot');
    if (selected) selected.classList.add('selected-slot');
    const sel = gameState.player.selectedSlot;
    if (sel !== null && gameState.player.inventory[sel] && gameState.player.inventory[sel].type === 'tool') {
      currentToolDisplay.textContent = gameState.player.inventory[sel].name;
    } else {
      currentToolDisplay.textContent = 'None selected';
    }
  }

  function selectItem(slotIndex) {
    gameState.player.selectedSlot = slotIndex;
    setupInventory();
  }

  // --- Time System ---
  function updateTime() {
    gameState.time.minute += 10;
    if (gameState.time.minute >= 60) {
      gameState.time.minute = 0;
      gameState.time.hour++;
      if (gameState.time.hour >= 24) {
        gameState.time.hour = 6;
        gameState.time.day++;
        updateCrops();
        if (Math.random() < 0.3) generateOres();
      }
    }
    const hourStr = gameState.time.hour.toString().padStart(2, '0');
    const minuteStr = gameState.time.minute.toString().padStart(2, '0');
    timeDisplay.textContent = `${hourStr}:${minuteStr}`;
    dayDisplay.textContent = gameState.time.day;
  }

  // --- Crop Growth ---
  function updateCrops() {
    for (const crop of gameState.crops) {
      if (crop.growth < crop.growthTime) {
        crop.growth++;
        if (crop.growth === crop.growthTime) crop.ready = true;
      }
    }
  }

  // --- Drawing Functions (with emoji and animation) ---
  let playerAnimFrame = 0;
  function drawGame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw map
    for (let y = 0; y < gameState.map.height; y++) {
      for (let x = 0; x < gameState.map.width; x++) {
        const tile = gameState.map.tiles[y][x];
        let emoji = EMOJIS.dirt;
        if (tile === 'water') emoji = EMOJIS.water;
        else if (tile === 'grass') emoji = EMOJIS.grass;
        else if (tile === 'tilled_soil') emoji = EMOJIS.tilled;
        drawEmoji(emoji, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE);
      }
    }
    // Merchant
    drawEmoji(EMOJIS.merchant, gameState.map.merchantPosition.x * TILE_SIZE, gameState.map.merchantPosition.y * TILE_SIZE, TILE_SIZE);
    // Ores
    for (const ore of gameState.ores) {
      drawEmoji(ore.emoji, ore.x, ore.y, TILE_SIZE);
    }
    // Crops
    for (const crop of gameState.crops) {
      let emoji = getCropEmoji(crop.type);
      if (!crop.ready) {
        // Animate growing: pulse opacity
        ctx.globalAlpha = 0.7 + 0.3 * Math.sin(Date.now()/400 + crop.x);
      }
      drawEmoji(emoji, crop.x, crop.y, TILE_SIZE);
      ctx.globalAlpha = 1;
      // Growth bar
      if (!crop.ready) {
        ctx.fillStyle = "#222";
        ctx.fillRect(crop.x, crop.y + TILE_SIZE - 6, TILE_SIZE, 5);
        ctx.fillStyle = "#6c3";
        ctx.fillRect(crop.x, crop.y + TILE_SIZE - 6, TILE_SIZE * (crop.growth / crop.growthTime), 5);
      }
    }
    // Player (emoji, animated bounce)
    const px = gameState.player.x;
    const py = gameState.player.y;
    const bounce = Math.sin(Date.now()/200) * 3;
    ctx.font = `${PLAYER_SIZE}px serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.save();
    ctx.translate(px + PLAYER_SIZE/2, py + PLAYER_SIZE/2 + bounce);
    ctx.rotate(0.05 * Math.sin(Date.now()/300));
    ctx.fillText(EMOJIS.player, 0, 0);
    ctx.restore();
  }

  function drawEmoji(emoji, x, y, size) {
    ctx.font = `${size}px serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(emoji, x, y);
  }

  function getCropEmoji(type) {
    if (type === 'Wheat') return EMOJIS.wheat;
    if (type === 'Carrot') return EMOJIS.carrot;
    if (type === 'Pumpkin') return EMOJIS.pumpkin;
    return EMOJIS.grass;
  }
  function getItemEmoji(item) {
    if (item.type === 'tool') return item.emoji;
    if (item.type === 'seed') return getCropEmoji(item.produces);
    if (item.type === 'crop') return getCropEmoji(item.name);
    if (item.type === 'ore') {
      if (item.name === 'Copper Ore') return EMOJIS.copper;
      if (item.name === 'Iron Ore') return EMOJIS.iron;
      if (item.name === 'Gold Ore') return EMOJIS.gold;
      if (item.name === 'Diamond') return EMOJIS.diamond;
    }
    return "â“";
  }

  // --- Input Handling ---
  function handleKeyDown(e) {
    const key = e.key.toLowerCase();
    if (key in gameState.keys) {
      gameState.keys[key] = true;
      if (key === 'e') interact();
    }
  }
  function handleKeyUp(e) {
    const key = e.key.toLowerCase();
    if (key in gameState.keys) gameState.keys[key] = false;
  }
  function updatePlayerPosition() {
    if (gameState.keys.w) { gameState.player.y -= gameState.player.speed; gameState.player.direction = 'up'; }
    if (gameState.keys.s) { gameState.player.y += gameState.player.speed; gameState.player.direction = 'down'; }
    if (gameState.keys.a) { gameState.player.x -= gameState.player.speed; gameState.player.direction = 'left'; }
    if (gameState.keys.d) { gameState.player.x += gameState.player.speed; gameState.player.direction = 'right'; }
    gameState.player.x = Math.max(0, Math.min(canvas.width - PLAYER_SIZE, gameState.player.x));
    gameState.player.y = Math.max(0, Math.min(canvas.height - PLAYER_SIZE, gameState.player.y));
  }

  // --- Mouse/Keyboard Interact ---
  function handleCanvasClick(e) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const { tileX, tileY } = getTileAtPixel(mouseX, mouseY);
    const obj = getObjectAtTile(tileX, tileY);
    if (!obj) return;
    if (obj.type === 'merchant') openMerchant();
    else if (obj.type === 'crop') harvestCrop(obj.index, true);
    else if (obj.type === 'ore') mineOre(obj.index, true);
    else if (obj.type === 'tilled_soil') plantCrop(tileX, tileY, getSelectedSeed());
  }
  function handleCanvasHover(e) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const { tileX, tileY } = getTileAtPixel(mouseX, mouseY);
    const obj = getObjectAtTile(tileX, tileY);
    canvas.style.cursor = obj ? 'pointer' : 'default';
  }
  function interact() {
    let tileX, tileY;
    switch (gameState.player.direction) {
      case 'up': tileX = Math.floor(gameState.player.x / TILE_SIZE); tileY = Math.floor((gameState.player.y - TILE_SIZE) / TILE_SIZE); break;
      case 'down': tileX = Math.floor(gameState.player.x / TILE_SIZE); tileY = Math.floor((gameState.player.y + PLAYER_SIZE) / TILE_SIZE); break;
      case 'left': tileX = Math.floor((gameState.player.x - TILE_SIZE) / TILE_SIZE); tileY = Math.floor(gameState.player.y / TILE_SIZE); break;
      case 'right': tileX = Math.floor((gameState.player.x + PLAYER_SIZE) / TILE_SIZE); tileY = Math.floor(gameState.player.y / TILE_SIZE); break;
    }
    const obj = getObjectAtTile(tileX, tileY);
    if (!obj) return;
    if (obj.type === 'merchant') openMerchant();
    else if (obj.type === 'crop') harvestCrop(obj.index, false);
    else if (obj.type === 'ore') mineOre(obj.index, false);
    else if (obj.type === 'tilled_soil') plantCrop(tileX, tileY, getSelectedSeed());
  }

  // --- Inventory/Seed Helpers ---
  function getSelectedSeed() {
    if (gameState.player.selectedSlot !== null) {
      const item = gameState.player.inventory[gameState.player.selectedSlot];
      if (item && item.type === 'seed') return item;
    }
    return gameState.player.inventory.find(item => item.type === 'seed');
  }

  // --- Crop/Ore/Plant Actions ---
  function harvestCrop(index, viaClick = false) {
    const crop = gameState.crops[index];
    let selectedItem = gameState.player.selectedSlot !== null 
      ? gameState.player.inventory[gameState.player.selectedSlot] 
      : null;
    if ((!selectedItem || selectedItem.name !== 'Sickle') && viaClick) {
      const sickleIndex = gameState.player.inventory.findIndex(i => i.name === 'Sickle');
      if (sickleIndex !== -1) {
        gameState.player.selectedSlot = sickleIndex;
        setupInventory();
        selectedItem = gameState.player.inventory[sickleIndex];
      }
    }
    const sickleEquipped = selectedItem && selectedItem.name === 'Sickle';
    if (sickleEquipped) {
      const harvestedItem = {
        name: crop.type,
        type: 'crop',
        value: getCropValue(crop.type),
        emoji: getCropEmoji(crop.type)
      };
      if (gameState.player.inventory.length < 10) {
        gameState.player.inventory.push(harvestedItem);
        gameState.crops.splice(index, 1);
        setupInventory();
      } else {
        alert('Inventory full!');
      }
    } else {
      alert('You need to select the sickle to harvest!');
    }
  }
  function getCropValue(cropType) {
    const seed = gameState.merchant.items.find(item => item.produces === cropType);
    return seed ? seed.price * 2 : 10;
  }
  function mineOre(index, viaClick = false) {
    const ore = gameState.ores[index];
    let selectedItem = gameState.player.selectedSlot !== null 
      ? gameState.player.inventory[gameState.player.selectedSlot] 
      : null;
    if ((!selectedItem || selectedItem.name !== 'Pickaxe') && viaClick) {
      const pickaxeIndex = gameState.player.inventory.findIndex(i => i.name === 'Pickaxe');
      if (pickaxeIndex !== -1) {
        gameState.player.selectedSlot = pickaxeIndex;
        setupInventory();
        selectedItem = gameState.player.inventory[pickaxeIndex];
      }
    }
    const pickaxeEquipped = selectedItem && selectedItem.name === 'Pickaxe';
    if (pickaxeEquipped) {
      const oreItem = {
        name: ore.type,
        type: 'ore',
        value: ore.value,
        emoji: ore.emoji
      };
      if (gameState.player.inventory.length < 10) {
        gameState.player.inventory.push(oreItem);
        gameState.ores.splice(index, 1);
        setupInventory();
      } else {
        alert('Inventory full!');
      }
    } else {
      alert('You need to select the pickaxe to mine!');
    }
  }
  function plantCrop(tileX, tileY, seed) {
    if (!seed) {
      alert('Select a seed in your inventory to plant!');
      return;
    }
    const seedIndex = gameState.player.inventory.indexOf(seed);
    if (seedIndex !== -1) {
      gameState.player.inventory.splice(seedIndex, 1);
      gameState.crops.push({
        x: tileX * TILE_SIZE,
        y: tileY * TILE_SIZE,
        type: seed.produces,
        growth: 0,
        growthTime: seed.growthTime,
        ready: false
      });
      setupInventory();
    }
  }

  // --- Merchant Modal ---
  function openMerchant() {
    const merchantItemsDiv = document.getElementById('merchantItems');
    merchantItemsDiv.innerHTML = '';
    gameState.merchant.items.forEach((item, index) => {
      const itemDiv = document.createElement('div');
      itemDiv.className = 'col-md-6 mb-3 merchant-item';
      itemDiv.innerHTML = `
        <div class="card h-100">
          <div class="card-body d-flex flex-column">
            <h5 class="card-title">${item.emoji || getItemEmoji(item)} ${item.name}</h5>
            <p class="card-text">${getItemDescription(item)}</p>
            <div class="mt-auto d-flex justify-content-between align-items-center">
              <span class="badge bg-primary">${item.price} coins</span>
              <button class="btn btn-primary btn-sm buy-btn" data-index="${index}">Buy</button>
            </div>
          </div>
        </div>
      `;
      merchantItemsDiv.appendChild(itemDiv);
    });
    updateSellPreview();
    merchantModal.show();
    document.querySelectorAll('.buy-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.target.getAttribute('data-index'));
        buyItem(index);
      });
    });
    document.querySelectorAll('.sell-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const action = e.target.textContent;
        if (action.includes('Crops')) {
          sellItems('crop');
        } else if (action.includes('Ores')) {
          sellItems('ore');
        } else {
          sellItems('all');
        }
      });
    });
  }
  function getItemDescription(item) {
    if (item.type === 'seed') {
      return `Grows into ${item.produces} in ${item.growthTime} days.`;
    } else if (item.type === 'item' && item.effect === 'growthSpeed') {
      return `Speeds up crop growth by ${(1 - item.value) * 100}%.`;
    }
    return '';
  }
  function updateSellPreview() {
    const sellPreview = document.getElementById('sellPreview');
    const crops = gameState.player.inventory.filter(item => item.type === 'crop');
    const ores = gameState.player.inventory.filter(item => item.type === 'ore');
    let previewHTML = '';
    if (crops.length > 0) {
      const cropValue = crops.reduce((sum, crop) => sum + crop.value, 0);
      previewHTML += `<p><strong>Crops:</strong> ${crops.length} items worth ${cropValue} coins</p>`;
    } else {
      previewHTML += `<p class="text-muted">No crops to sell</p>`;
    }
    if (ores.length > 0) {
      const oreValue = ores.reduce((sum, ore) => sum + ore.value, 0);
      previewHTML += `<p><strong>Ores:</strong> ${ores.length} items worth ${oreValue} coins</p>`;
    } else {
      previewHTML += `<p class="text-muted">No ores to sell</p>`;
    }
    sellPreview.innerHTML = previewHTML;
  }
  function buyItem(index) {
    const item = gameState.merchant.items[index];
    if (gameState.player.coins >= item.price) {
      if (gameState.player.inventory.length < 10) {
        gameState.player.coins -= item.price;
        gameState.player.inventory.push({...item});
        setupInventory();
        updateSellPreview();
      } else {
        alert('Inventory full!');
      }
    } else {
      alert('Not enough coins!');
    }
  }
  function sellItems(type) {
    let itemsToSell = [];
    let itemsToKeep = [];
    if (type === 'all') {
      itemsToSell = gameState.player.inventory.filter(item => item.type === 'crop' || item.type === 'ore');
      itemsToKeep = gameState.player.inventory.filter(item => item.type !== 'crop' && item.type !== 'ore');
    } else {
      itemsToSell = gameState.player.inventory.filter(item => item.type === type);
      itemsToKeep = gameState.player.inventory.filter(item => item.type !== type);
    }
    const total = itemsToSell.reduce((sum, item) => sum + item.value, 0);
    if (itemsToSell.length > 0) {
      gameState.player.inventory = itemsToKeep;
      gameState.player.coins += total;
      setupInventory();
      updateSellPreview();
      const feedback = document.createElement('div');
      feedback.className = 'alert alert-success mt-3';
      feedback.textContent = `Sold ${itemsToSell.length} items for ${total} coins!`;
      document.querySelector('.modal-body').prepend(feedback);
      setTimeout(() => feedback.remove(), 2000);
    } else {
      const feedback = document.createElement('div');
      feedback.className = 'alert alert-warning mt-3';
      feedback.textContent = `No items to sell!`;
      document.querySelector('.modal-body').prepend(feedback);
      setTimeout(() => feedback.remove(), 2000);
    }
  }

  // --- Game Loop ---
  function gameLoop() {
    if (!gameState.time.paused) {
      updateTime();
      updatePlayerPosition();
    }
    drawGame();
    requestAnimationFrame(gameLoop);
  }

  // --- Init ---
  function initGame() {
    generateMap();
    generateOres();
    setupInventory();
    gameState.player.inventory.push(gameState.player.tools.sickle);
    gameState.player.inventory.push(gameState.player.tools.pickaxe);
    merchantModal = new bootstrap.Modal(document.getElementById('merchantModal'));
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    canvas.addEventListener('click', handleCanvasClick);
    canvas.addEventListener('mousemove', handleCanvasHover);
    canvas.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') interact();
    });
    gameLoop();
  }
  window.onload = initGame;
</script>

<script>
// --- Background Music ---
const music = new Audio('{{site.baseurl}}/assets/audio/27mariocircuit.mp3');
music.loop = true;
music.volume = 0.5;
function startMusicOnce() {
  music.play().catch(() => {});
  window.removeEventListener('click', startMusicOnce);
  window.removeEventListener('keydown', startMusicOnce);
}
window.addEventListener('click', startMusicOnce);
window.addEventListener('keydown', startMusicOnce);
</script>